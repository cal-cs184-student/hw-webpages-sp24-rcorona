<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Rodolfo Corona Rodriguez (3034203306) </h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this homework Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

  <p>
<b>Top-down Walkthrough: </b> First, the algorithm determines the bounding box of the triangle by finding the maximum and minimum x and y coordinates in \{x0, x1, x2\} and \{y0, y1, y2\}. 
  Having determined the bounding box a nested for loop (one for x and one for y coordinates) from the minimum (integer) x,y to the maximum, checking if the coordinate (x + 0.5, y + 0.5) 
  lies within the triangle (using a helper function named <i>inside</i>, which takes as input the three triangle vertex coordinates and a query point). 
  Coordinates determined to be within the triangle are filled onto the screen with the provided color argument. 
  </p>
  <p>
  The <i>inside</i> helper function uses a <i>line_test</i> helper which, given two points on a line and a query point, determines which half-plane the query point lies in (or if it lies directly on the line). 
  As a first step, the <i>inside</i> function checks which direction denotes the inside of the triangle if we follow lines P0 --> P1, P1 --> P2, and P2 --> P0. 
  The direction is determined by performing a line test using P0 and P1 as the two line points and P2 as the query point; if the line test is positive then points in the triangle will 
  lie on the positive half-plane of each triangle edge (or on the negative half-plane if the line test is negative). 
  Having determined the correct direction, the function then performs a line test for the query pixel on each edge (determined by each pair of triangle vertices), if all line tests are 0 or 
  in the inside direction then the function returned true (and otherwise false). 
  </p>
  <p>
  The <i>line_test</i> helper function performs the line test by first defining two vectors: V = (x - x0, y - y0), i.e. the vector from the first line point to the query point, and 
  N = (-(y1 - y0), x1 - x0), i.e. a vector perpendicular to the line. Having defined these two vectors, the function returns the result of their dot product, which will be positive
  if the query point lies on the positive half-plane of the line, 0 if it lies directly on the line, or negative if it lies in the negative half-plane. 
  </p>
  <p>
  <b>Difficult Part</b> I had the most trouble with making the algorithm robust to triangle vertex winding ordering. At first my algorithm assumed that all 3 line tests being non-negative 
  <i>always</i> means that a point lies in the triangle, however this is only true if P2 lies in the positive half-plane of the edge P0-->P1. If P2 lies on the negative half-plane 
  then the line tests must all be non-positive instead. Adding this check resolved the issue. 
  </p>
<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/image1.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image2.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/image3.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image4.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>



<h3 align="middle">Part 3: Transforms</h3>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
