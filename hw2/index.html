<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Geometric Modeling</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 2: Geometric Modeling</h1>
<h2 align="middle">Rodolfo Corona Rodriguez (3034203306) </h2>
<h2 align="middle">Website: https://cal-cs184-student.github.io/hw-webpages-sp24-rcorona/hw2/index.html </h2>

<br><br>

<h2 align="middle">Overview</h2>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

<p>
<b>Casteljau's Algorithm Explanation:</b> Casteljau's algorithm is given a set of <i>n</i> vectors, known as <i>control points</i> and uses them to evaluate a degree-n <i>Bezier curve</i>.<br>
This curve is parameterized by a parameter <i>t</i> in [0,1], and the curve is the result of evaluating the Bezier curve at points within the range [0,1]. <br><br>
The algorithm can evaluate the location on the curve for a point t through n-1 recursive steps. At each level of the recursion, the algorithm is provided with a list of k intermediate control points (with the starting level being the original control points themselves). <br>
For each contiguos pair of points (p1, p2) a new intermediate point is computed as (1-t) * p1 + t * p2, and the set of all k-1 intermediate points resulting from interpolating each pair is passed down to the next level of recursion. <br>
The termination case of the recursion is when there is only one intermediate point provided, which will be precisely the point along the Bezier curve at coordinate t to be returned. 
</p><br>
<p>
<b>Implementation:</b> I implemented the algorithm recursively. At each recursion level I define an std::vector&ltVector2D&gt which will contain the intermediate points at the next recursion level. <br>
I then loop over pairs (points[i], points[i+1]) in a sliding window from i=0 to i=points.size() - 1. <br>
Each pair is interpolated into intermediate point p = (1-t) * p1 + t * p2, which is pushed onto the vector of intermediate points. <br>
At the termination of the loop, the vector of intermediate points is returned. 
</p>

<p>
<b>Results:</b> Below I visualize results for the algorithm: 
</p>
  
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task1_cp.png" align="middle" width="400px"/>
        <figcaption align="middle">6 Control points for my Bezier curve.</figcaption>
      </td>
      <td>
        <img src="images/task1_level1.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 1.</figcaption>
      </td>
    </tr>
        <tr>
      <td>
        <img src="images/task1_level2.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 2.</figcaption>
      </td>
      <td>
        <img src="images/task1_level3.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 3.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/task1_level4.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 4.</figcaption>
      </td>
      <td>
        <img src="images/task1_level5.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 5, the evaluated point at t.</figcaption>
      </td>
    </tr>

    <tr>
      <td>
        <img src="images/task1_curve.png" align="middle" width="400px"/>
        <figcaption align="middle">Full Bezier curve.</figcaption>
      </td>
      <td>
        <img src="images/task1_diff_curve.png" align="middle" width="400px"/>
        <figcaption align="middle">Curve with moved control points and t scrolled up.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<p>
<b>Explanation:</b> The de Casteljau's algorithm does not fundamentally change when applied to Bezier surfaces, the same algorithm used to evaluate a point on a single line is instead used multiple times to produce a point on the surface. <br>
  Given a (n * n) control points and a coordinate (u, v) to evaluate within the surface, the algorithm works as follows: <br>
  Without loss of generality, we first evaluate the coordinate u using the 1D de Casteljau algorithm on each of the n rows of control points, this will yield the point for u on each of the n Bezier curves defined by the rows. <br>
  Let's denote this set of n evaluated u points as p_u. <br>
  The set of points p_u itself now serve as a set of control points defining a Bezier curve, and evaluating this Bezier curve at coordinate v using the 1D de Casteljau algorithm will yield the final point with coordinate (u,v) on the Bezier surface.
</p>
  <br>
<p>
<b>Implementation:</b> <br>
<i>evaluate_step:</i> This method is identical to its 2D counterpart for Part 1, which is described above. The only difference is that the operations are all now on Vector3D objects instead of Vector2D. 
  <br>
<i>evaluate_1D:</i> Given the input control points, this method begins by defining a std::vector&lbVector3D&rb which is used as a buffer to contain intermediate points to interpolate at each level of the de Casterljau algorithm recursion. <br>
  The method then performs a while loop which recurses into <i>evaluate_step</i> using the intermediate control points until the size of the vector returned by the recursion is 1 (at which point we have the evaluated point on the Bezier curve), <br>
  at which point the singular Vector3D containing the evaluated point is returned. <br>
  <br>
  <i>evaluate:</i> This method first creates a std::vector&lbVector3D&rb which it fills with the evaluated points at coordinate u within each of the Bezier curves defined by the rows of the control points by calling <i>evaluate_1D</i>. <br>
  This vector, containing the evaluated u points, is then passed as input as the control point vector to <i>evaluate_1D</i> with the parameter v in order to yield the final evaluated point at coordinate (u,v) on the Bezier surface. <br>
  This point is returned. 
</p>

<p>
Below we can see a couple of screenshots of the Bezier surface evaluated from <i>teapot.bez</i>. 
</p>
  
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task2_1.png" align="middle" width="400px"/>
        <figcaption align="middle">Side of teapot.</figcaption>
      </td>
      <td>
        <img src="images/task2_2.png" align="middle" width="400px"/>
        <figcaption align="middle">Back of teapot.</figcaption>
      </td>
    </tr>
</div>

<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h2 align="middle">Part III: Area-Weighted Vertex Normals</h2>

<p>
<b>Implementation:</b><br> For my implementation, I first define a <i>normals</i> vector&lt;Vector3D&gt; and a <i>areas </i>vector&lt;float&gt; for collecting the surface normals and areas, respectively, 
  of all triangle faces in the fan around the given vertex. <br>
  Next, I iterate over all faces around the vertex by starting with the half-edge, <i>h</i>, the vertex points to and updating it as <i>h = h-%gt;twin()-&gt;next()</i> in each iteration. 
  For each iteration, I retrive the face associated with the current half-edge, <i>f = h-&gt;face()</i> and <b>check if the face lies on the boundary or not</b>. 
  If the face does not lie within the boundary, then I compute its area and add both its area and normal to the <i>areas</i> and <i>normals</i> vectors. <br><br>

  To compute the area of a given face, I define a helper function, <i>float Face::area</i>, which first collects all 3 of the face's vertices (v0, v1, and v2) in a vector by iterating through
  with the half-edge <i>next()</i> method. Having collected all three vertices, the area is simply half of the area of the trapezoid defined by the vector cross product between 
  the vectors v0-->v1 and v0-->v2, i.e. 1/2 * |cross(v1 - v0, v2 - v0).norm()|. <br><br>

  Having collected all areas and normals pertaining to the faces in the fan around the vertices, I then compute the weighted normal as follows: 
  First, I loop over and sum all areas into a variable <i>areas_total</i>.
  Next, I define a Vector3D named <i>weighted_normal</i> which will contain the final weighted normal, and set its value as the sum of <i>areas[i] / areas_total * normals[i]</i> by iterating 
  over all areas/normals. <br>
  After performing the weighted sum, <i>weighted_normal</i> is returned. 
</p>

<p>
Below we can see an example of <i>teapot.dae</i> and <i>beetle.dae</i> (which contains boundaries) each pre and post area-weighted vertex normal shading. 
As may be clearly seen, both are smoother after the shading is turned on. 
</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task3_teapot_pre.png" align="middle" width="400px"/>
        <figcaption align="middle">Teapot before area-weighted vertex normal shading.</figcaption>
      </td>
      <td>
        <img src="images/task3_teapot_post.png" align="middle" width="400px"/>
        <figcaption align="middle">Teapot after area-weighted vertex normal shading.</figcaption>
      </td>
    </tr>
        <tr>
      <td>
        <img src="images/task3_beetle_pre.png" align="middle" width="400px"/>
        <figcaption align="middle">Beetle before area-weighted vertex normal shading.</figcaption>
      </td>
      <td>
        <img src="images/task3_beetle_post.png" align="middle" width="400px"/>
        <figcaption align="middle">Beetle after area-weighted vertex normal shading.</figcaption>
      </td>
    </tr>
</div>

<h2 align="middle">Part IV: Edge Flip</h2>

<p>
<b>Implementation:</b> In my implementation I first chck to see if the given edge is on the boundary, if so I simply return it. 
  If it is not on the boundary, then I first assign all 4 remaining edges across both triangles to variables <i>e1, e2, e3,</i> and <i>e4</i> by traversing half-edges and twins as needed. 
  Similarly, I collect all six half edges associated with the two triangles, as well as the four vertices and two faces. <br><br>
  Next, I continue by assigning pointers to each variable, starting with vertices, then faces, then edges, and finally half-edges. 
</p>

<p>
  <b>Debugging Journey:</b> During development of the method, I first began by trying to only assign pointers that I thought were necessary (contrary to the suggestion in the project spec!). <br>
  I also found that there were certain symmetries in assignments between half-edges, which led me to try implementing a helper method which I would call once per triangle. 
Unfortunately, yet unsurprisignly, I found that there were certain corner cases in which a hole would be formed in the mesh as a result of the flip operation. <br>
Before diving into debugging, I found that I was able to get the method working by switching strategies and making sure that I was assigning every component pertaining to the two triangles first. <br>
Below I have included an image of a schematic I drew in order to reason about pointer assignments in the data structure. I found that by following the schematic I was able to get a working implementation. <br>
  In the end, I found that a thorough and explicit solution was easier to get correct than to try to express it more elegantly by trying to leverage symmetry in assignments. 
</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task4_schema.jpeg" align="middle" width="400px"/>
        <figcaption align="middle">Schematic drawings that I used to reason about data pointer assignments.</figcaption>
      </td>
    </tr>
</div>
  
</body>
</html>
