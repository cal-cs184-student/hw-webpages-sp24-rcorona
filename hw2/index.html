<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Geometric Modeling</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 2: Geometric Modeling</h1>
<h2 align="middle">Rodolfo Corona Rodriguez (3034203306) </h2>
<h2 align="middle">Website: https://cal-cs184-student.github.io/hw-webpages-sp24-rcorona/hw2/index.html </h2>

<br><br>

<h2 align="middle">Overview</h2>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

<p>
<b>Casteljau's Algorithm Explanation:</b> Casteljau's algorithm is given a set of <i>n</i> vectors, known as <i>control points</i> and uses them to evaluate a degree-n <i>Bezier curve</i>.<br>
This curve is parameterized by a parameter <i>t</i> in [0,1], and the curve is the result of evaluating the Bezier curve at points within the range [0,1]. <br><br>
The algorithm can evaluate the location on the curve for a point t through n-1 recursive steps. At each level of the recursion, the algorithm is provided with a list of k intermediate control points (with the starting level being the original control points themselves). <br>
For each contiguos pair of points (p1, p2) a new intermediate point is computed as (1-t) * p1 + t * p2, and the set of all k-1 intermediate points resulting from interpolating each pair is passed down to the next level of recursion. <br>
The termination case of the recursion is when there is only one intermediate point provided, which will be precisely the point along the Bezier curve at coordinate t to be returned. 
</p><br>
<p>
<b>Implementation:</b> I implemented the algorithm recursively. At each recursion level I define an std::vector&ltVector2D&gt which will contain the intermediate points at the next recursion level. <br>
I then loop over pairs (points[i], points[i+1]) in a sliding window from i=0 to i=points.size() - 1. <br>
Each pair is interpolated into intermediate point p = (1-t) * p1 + t * p2, which is pushed onto the vector of intermediate points. <br>
At the termination of the loop, the vector of intermediate points is returned. 
</p>

<p>
<b>Results:</b> Below I visualize results for the algorithm: 
</p>
  
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task1_cp.png" align="middle" width="400px"/>
        <figcaption align="middle">6 Control points for my Bezier curve.</figcaption>
      </td>
      <td>
        <img src="images/task1_level1.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 1.</figcaption>
      </td>
    </tr>
        <tr>
      <td>
        <img src="images/task1_level2.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 2.</figcaption>
      </td>
      <td>
        <img src="images/task1_level3.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 3.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/task1_level4.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 4.</figcaption>
      </td>
      <td>
        <img src="images/task1_level5.png" align="middle" width="400px"/>
        <figcaption align="middle">Level 5, the evaluated point at t.</figcaption>
      </td>
    </tr>

    <tr>
      <td>
        <img src="images/task1_curve.png" align="middle" width="400px"/>
        <figcaption align="middle">Full Bezier curve.</figcaption>
      </td>
      <td>
        <img src="images/task1_diff_curve.png" align="middle" width="400px"/>
        <figcaption align="middle">Curve with moved control points and t scrolled up.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<p>
<b>Explanation:</b> The de Casteljau's algorithm does not fundamentally change when applied to Bezier surfaces, the same algorithm used to evaluate a point on a single line is instead used multiple times to produce a point on the surface. <br>
  Given a (n * n) control points and a coordinate (u, v) to evaluate within the surface, the algorithm works as follows: <br>
  Without loss of generality, we first evaluate the coordinate u using the 1D de Casteljau algorithm on each of the n rows of control points, this will yield the point for u on each of the n Bezier curves defined by the rows. <br>
  Let's denote this set of n evaluated u points as p_u. <br>
  The set of points p_u itself now serve as a set of control points defining a Bezier curve, and evaluating this Bezier curve at coordinate v using the 1D de Casteljau algorithm will yield the final point with coordinate (u,v) on the Bezier surface.
</p>
  <br>
<p>
<b>Implementation:</b> <br>
<i>evaluate_step:</i> This method is identical to its 2D counterpart for Part 1, which is described above. The only difference is that the operations are all now on Vector3D objects instead of Vector2D. 
  <br>
<i>evaluate_1D:</i> This method ...
</p>
</body>
</html>
